{"ast":null,"code":"var _jsxFileName = \"C:\\\\workspace\\\\react\\\\my-app\\\\src\\\\exam\\\\Exam.js\";\n// Component 예제 1\n\nimport { Component } from \"react\";\n\n/*  Component \r\n    React 앱의 구성 요소 중 하나로, \r\n    재사용 가능하도록 만들어져 있으며, \r\n    UI를 작은 조각으로 나누어 관리 \r\n    컴포넌트 명은 보통 대문자로 작성 \r\n\r\n    컴포넌트 아래와 같이 두가지로 나뉨 \r\n    1. 클래스형 컴포넌트 : React.Component 클래스를 상속 받아 구현 \r\n\r\n    장점 : \r\n     - 생명주기 메서드 제공 : \r\n     componentDidMount, componentDidUpdate, componentWillUnmount... 등의 생명주기 메서드를 사용할 수 있어\r\n     컴포넌트의 생명주기 동안 특정 동작을 쉽게 구현할 수 있음 \r\n\r\n    단점 : \r\n     - 복잡 : 문법이 복잡하고, this 키워드를 자주 사용해야 하므로 코드를 작성하고 이해하기 어려울 수 있음 \r\n     - 함수형 컴포넌트에 비해서 코드 길이 증가 \r\n     - Hooks 도입 이후 감소된 사용  \r\n\r\n    2. 함수형 컴포넌트 : 함수 형태로 구현 \r\n    \r\n    장점 : \r\n     - 간결함 : 코드 길이가 줄어들고, this 키워드 사용할 필요가 없어 이해하기 쉬움 \r\n     - Hooks 사용 가능 : Hooks를 사용하여 함수형 컴포넌트에서도 \r\n                        상태관리와 생명주기 메서드와 유사한 기능을 구현할 수 있음 \r\n     - 성능 최적화 : 메모리 사용이 더 적고, 성능이 좋음 \r\n\r\n    단점 : \r\n     - Hooks를 사용한 생명주기 관리가 클래스형 컴포넌트의 메서드 보다 직관적이지 않을 수 있음 \r\n       (러닝커브 있을 수 있음)\r\n    - 레거시 코드 호환이 떨어짐 (기존 클래스형 컴포넌트와 호환이 어려울 수 있음)   \r\n\r\n    * state 와 props \r\n    React 컴포넌트는 두 종류의 데이터를 다룸 \r\n    1. props (속성) : 부모 컴포넌트로부터 전달되는 읽기 전용 데이터 \r\n    2. state (상태) : 컴포넌트의 내부에서 관리되며 컴포넌트의 동작 및 UI 렌더링을 제어하는데 사용 \r\n                     (내부 상태를 관리하는데 사용)\r\n\r\n*/\n\n// 클래스형 컴포넌트 \nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass Exam1 extends Component {\n  // 컴포넌트 선언부 \n\n  // 컴포넌트 정의 \n\n  // 필드 \n  // 생성자 \n  constructor(prop) {\n    // prop : 부모에게 받은 속성 \n    super(prop);\n    /*\r\n        React에서 상태(state)와 변수 (variable)는 둘 다 데이터 저장과 관련되어 있지만, \r\n        각기 다른 역할과 사용방식을 가짐 \r\n        - 상태 (state)는 React 컴포넌트에서 데이터가 저장되는 곳으로, \r\n          상태 값이 변경될 때마다 컴포넌트가 다시 렌더링\r\n        - 변수는 컴포넌트 내에서 상태가 아닌 다른 데이터를 저장하기 위해 사용되므로 \r\n          변수 값이 변경되어도 컴포넌트든 다시 렌더링되지 않음 \r\n      */\n    // 메서드 (함수)\n    this.handleClick = () => {\n      // handleClick이라는 이름의 함수를 정의 \n      this.setState({\n        count: this.state.count + 1\n      });\n      // 이 컴포넌트의 상태(state) 중 count를 현재 상태값에서 +1 한 값으로 상태를 다시 세팅(변경)\n    };\n    this.state = {\n      count: 0\n    };\n    // state : 컴포넌트 내부 상태를 관리하는데 사용되는 데이터 \n    // count는 Exam1이라는 컴포넌트의 내부 상태 중 하나의 데이터, \n    // 초기 값이 0으로 설정됨 \n  }\n\n  // render 함수 (클래스형 컴포넌트에서 필수 구문)\n  render() {\n    // 클래스형 컴포넌트에서 render함수 안에 return 구문을 필수로 작성해야 한다. \n    // return에는 무엇을 렌더링할지 작성하면 됨 \n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: [\"Count : \", this.state.count]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 82,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: this.handleClick,\n        children: \"\\uC99D\\uAC00\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 13\n    }, this);\n  }\n}\nexport default Exam1; // 컴포넌트 내보내기 \n// 해당 Exam1.js 파일에서 기본적으로 내보내는 컴포넌트의 이름은 Exam1","map":{"version":3,"names":["Component","jsxDEV","_jsxDEV","Exam1","constructor","prop","handleClick","setState","count","state","render","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick"],"sources":["C:/workspace/react/my-app/src/exam/Exam.js"],"sourcesContent":["// Component 예제 1\r\n\r\nimport { Component } from \"react\";\r\n\r\n/*  Component \r\n    React 앱의 구성 요소 중 하나로, \r\n    재사용 가능하도록 만들어져 있으며, \r\n    UI를 작은 조각으로 나누어 관리 \r\n    컴포넌트 명은 보통 대문자로 작성 \r\n\r\n    컴포넌트 아래와 같이 두가지로 나뉨 \r\n    1. 클래스형 컴포넌트 : React.Component 클래스를 상속 받아 구현 \r\n\r\n    장점 : \r\n     - 생명주기 메서드 제공 : \r\n     componentDidMount, componentDidUpdate, componentWillUnmount... 등의 생명주기 메서드를 사용할 수 있어\r\n     컴포넌트의 생명주기 동안 특정 동작을 쉽게 구현할 수 있음 \r\n\r\n    단점 : \r\n     - 복잡 : 문법이 복잡하고, this 키워드를 자주 사용해야 하므로 코드를 작성하고 이해하기 어려울 수 있음 \r\n     - 함수형 컴포넌트에 비해서 코드 길이 증가 \r\n     - Hooks 도입 이후 감소된 사용  \r\n\r\n    2. 함수형 컴포넌트 : 함수 형태로 구현 \r\n    \r\n    장점 : \r\n     - 간결함 : 코드 길이가 줄어들고, this 키워드 사용할 필요가 없어 이해하기 쉬움 \r\n     - Hooks 사용 가능 : Hooks를 사용하여 함수형 컴포넌트에서도 \r\n                        상태관리와 생명주기 메서드와 유사한 기능을 구현할 수 있음 \r\n     - 성능 최적화 : 메모리 사용이 더 적고, 성능이 좋음 \r\n\r\n    단점 : \r\n     - Hooks를 사용한 생명주기 관리가 클래스형 컴포넌트의 메서드 보다 직관적이지 않을 수 있음 \r\n       (러닝커브 있을 수 있음)\r\n    - 레거시 코드 호환이 떨어짐 (기존 클래스형 컴포넌트와 호환이 어려울 수 있음)   \r\n\r\n    * state 와 props \r\n    React 컴포넌트는 두 종류의 데이터를 다룸 \r\n    1. props (속성) : 부모 컴포넌트로부터 전달되는 읽기 전용 데이터 \r\n    2. state (상태) : 컴포넌트의 내부에서 관리되며 컴포넌트의 동작 및 UI 렌더링을 제어하는데 사용 \r\n                     (내부 상태를 관리하는데 사용)\r\n\r\n*/\r\n\r\n// 클래스형 컴포넌트 \r\nclass Exam1 extends Component { // 컴포넌트 선언부 \r\n\r\n    // 컴포넌트 정의 \r\n\r\n    // 필드 \r\n    // 생성자 \r\n    constructor(prop) { // prop : 부모에게 받은 속성 \r\n        super(prop); \r\n        this.state = { count : 0 }; \r\n        // state : 컴포넌트 내부 상태를 관리하는데 사용되는 데이터 \r\n        // count는 Exam1이라는 컴포넌트의 내부 상태 중 하나의 데이터, \r\n        // 초기 값이 0으로 설정됨 \r\n    }\r\n\r\n    /*\r\n        React에서 상태(state)와 변수 (variable)는 둘 다 데이터 저장과 관련되어 있지만, \r\n        각기 다른 역할과 사용방식을 가짐 \r\n        - 상태 (state)는 React 컴포넌트에서 데이터가 저장되는 곳으로, \r\n          상태 값이 변경될 때마다 컴포넌트가 다시 렌더링\r\n        - 변수는 컴포넌트 내에서 상태가 아닌 다른 데이터를 저장하기 위해 사용되므로 \r\n          변수 값이 변경되어도 컴포넌트든 다시 렌더링되지 않음 \r\n\r\n    */\r\n\r\n    // 메서드 (함수)\r\n    handleClick = () => { // handleClick이라는 이름의 함수를 정의 \r\n        this.setState({ count : this.state.count + 1}); \r\n        // 이 컴포넌트의 상태(state) 중 count를 현재 상태값에서 +1 한 값으로 상태를 다시 세팅(변경)\r\n    }\r\n\r\n    // render 함수 (클래스형 컴포넌트에서 필수 구문)\r\n    render() {\r\n        // 클래스형 컴포넌트에서 render함수 안에 return 구문을 필수로 작성해야 한다. \r\n        // return에는 무엇을 렌더링할지 작성하면 됨 \r\n        return (\r\n            <div>\r\n                <h1>Count : {this.state.count}</h1>\r\n                <button onClick={this.handleClick}>증가</button>\r\n            </div>\r\n        ); \r\n\r\n    }\r\n}\r\n\r\nexport default Exam1; // 컴포넌트 내보내기 \r\n                      // 해당 Exam1.js 파일에서 기본적으로 내보내는 컴포넌트의 이름은 Exam1 \r\n"],"mappings":";AAAA;;AAEA,SAASA,SAAS,QAAQ,OAAO;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,KAAK,SAASH,SAAS,CAAC;EAAE;;EAE5B;;EAEA;EACA;EACAI,WAAWA,CAACC,IAAI,EAAE;IAAE;IAChB,KAAK,CAACA,IAAI,CAAC;IAOf;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IAGI;IAAA,KACAC,WAAW,GAAG,MAAM;MAAE;MAClB,IAAI,CAACC,QAAQ,CAAC;QAAEC,KAAK,EAAG,IAAI,CAACC,KAAK,CAACD,KAAK,GAAG;MAAC,CAAC,CAAC;MAC9C;IACJ,CAAC;IApBG,IAAI,CAACC,KAAK,GAAG;MAAED,KAAK,EAAG;IAAE,CAAC;IAC1B;IACA;IACA;EACJ;;EAkBA;EACAE,MAAMA,CAAA,EAAG;IACL;IACA;IACA,oBACIR,OAAA;MAAAS,QAAA,gBACIT,OAAA;QAAAS,QAAA,GAAI,UAAQ,EAAC,IAAI,CAACF,KAAK,CAACD,KAAK;MAAA;QAAAI,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAK,CAAC,eACnCb,OAAA;QAAQc,OAAO,EAAE,IAAI,CAACV,WAAY;QAAAK,QAAA,EAAC;MAAE;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC7C,CAAC;EAGd;AACJ;AAEA,eAAeZ,KAAK,CAAC,CAAC;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}